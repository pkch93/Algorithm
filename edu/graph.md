# 그래프 (Graph)

그래프는 아이템들과 이들의 연결 관계를 표현한다.
연결 관계를 표현할 때 `정점(Vertex)`들의 집합과 이 `정점`을 연결하는 `간선(Edge)`으로 이뤄진 자료구조이다.

- 용어 표현

    |V| : 정점`Vertex`의 개수
    |E| : 그래프에 포함된 간선`Edge`의 개수
    > |V|개의 정점을 가지는 그래프는 최대 ![total edge](https://latex.codecogs.com/gif.latex?\inline&space;|V||V|-1&space;\over&space;2)개의 간선이 가능하다.
    
    경로는 간선들을 순서대로 나열한 것이다. 이때 경로 중 한 정점을 최대
    한 번만 지나는 경로를 `단순경로`라고 한다.
    시작한 정점에서 끝나는 경로를 `사이클`이라고 한다.
    
    인접정점 : 두 개의 정점에 간선이 존재하면 서로 `인접`했다고 한다.
    
- 그래프 유형

    1. 무향 그래프 (Undirected Graph) : 간선의 방향성이 없는 그래프  
    2. 유향 그래프 (Directed Graph) : 간선의 방향성이 있는 그래프
    3. 가중치 그래프(Weighted Graph) : 간선에 가중치가 있는 그래프
    4. 사이클이 없는 방향 그래프 (DAG, Directed Acyclic Graph) : Tree가 이 유형에 해당한다.
    5. 완전 그래프 : 정점에 대해 가능한 모든 간선을 가진 그래프 (![total edge](https://latex.codecogs.com/gif.latex?\inline&space;|V||V|-1&space;\over&space;2)개의 간선을 가진 그래프)
    6. 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

선형 자료구조 또는 트리 자료구조로 표현하기 힘든 N:N 관계의 원소들을 표현하는 데 유리하다.    

그래프는 `dfs / bfs`로 모든 Vertex를 탐색할 수 있다.

> 그래프는 사이클이 생길 수 있다. 반면 트리는 사이클이 없는 그래프이다.

## 서로소 집합 (Disjoint-Sets)

> 서로소는 교집합이 없다는 의미

집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 대표자(representative)하고 한다.

서로소 집합을 표현하기 위해서는 `연결 리스트` 또는 `트리`를 사용한다.

### 서로소 집합 표현

1. 연결리스트

2. 트리

하나의 집합을 하나의 트리로 표현하는 방법

자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다.

## 최소 신장 트리(MST, Minimum Spanning Tree)

모든 정점을 연결하는 간선들의 가중치 합이 최소가 되는 트리

> 신장트리?
>
> n개의 정점으로 이뤄진 무향 그래프에서 n개의 정점과 n-1개의 간선으로
> 이루어진 트리

MST를 표현하는 방법으로는 `prim`알고리즘과 `kruskal`알고리즘이 있다.

### 1. Prim 알고리즘

하나의 정점에서 연결된 간선들 중에서 하나씩 선택하면서 MST를 만들어 가는
방식

1. 임의 정점을 하나 선택하여 시작 
2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점
   선택   
3. 모든 정점이 선택될 때까지 반복

> 이때 서로소인 2개의 집합 (MST인 정점 / 선택되지 않은 정점) 정보를
> 유지해야한다.

```
prim(G, r)
    loop a in G.V
        a.key = inf
        a.p = null
    r.key = 0
    Q <- G.V
    loop not empty Q  // 정점의 갯수만큼 돌면 된다.
        a <- Extract_MIN(Q)
        loop v to G.Adj[u]
            if v in Q and w(a, v) < v.key
            // 선택된 정점의 인접 정점 중에서 방문하지 않은 경우 
                v.p <- u
                v.key <- w(a, v)
```

### 2. Kruskal 알고리즘

간선을 하나씩 선택해서 MST를 찾는 알고리즘

1. 처음에 모든 간선을 가중치에 따라 오름차순 정렬
2. 가중치가 낮은 간선부터 선택하면서 트리를 증가시킨다.
3. n-1개의 간선이 선택될 때까지 2번 반복

> 사이클이 존재하는지 판단하기 위해 disjoint-set을 사용한다.

```
kruskal(G, w)
    A <- {}  // A는 현재 MST로 선택된 Edge를 저장
    loop v in G.V
        makeSet(v)
    
    sort(G.E by w) // 그래프의 간선들을 w(가중치)에 따라 정렬
    loop 가중치가 가장 작은 간선부터 G.E의 모든 간선
        if findSet(u) != findSet(v)
            A <- A U (u, v) // A에 (u, v) edge 추가 
            unionSet(u, v)
    return A
```

## 최단 경로 알고리즘

> 최단경로란?
>
> 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의
> 가중치 합이 최소인 경로

- 구현 방법

1. 다익스트라(dijkstra) 알고리즘

    음의 가중치를 허용하지 않는다.

2. 벨만-포드(Bellman-Ford) 알고리즘

    음의 가중치를 허용한다.
    
3. 플로이드-워샬(Floyd-Warshall) 알고리즘

    모든 정점들에 대한 최단 경로를 구하는 알고리즘
    
### 다익스트라(Dijkstra) 알고리즘

시작 정점에서 `거리가 최소인 정점`을 선택해 나가면서 최단 경로를 구하는
방식

시작정점`s`에서 끝정점`t`까지의 최단경로에 정점 x가 존재할 수 있다.

`Greedy`기법을 이용한 알고리즘으로 `prim 알고리즘`과 매우 유사하다.

#### pseudo code
```
s: 시작정점 / adj: 인접 행렬 / dist: 거리 / V: 정점 집합 / U: 선택된 정점 집합
Dijkstra(s, adj, dist)
    U = {s}
    loop v in V
        dist[v] <- adj[s][v]
    while U != V
        dist[w]가 최소인 정점 w 중 방문하지 않은 정점 선택
        U <- U U {w}
        loop w에 인접한 모든 정점 v
            dist[v] <- min(dist[v], dist[w] + adj[w][v]
```

### 플로이드-워샬(Floyd-Warshall) 알고리즘

모든 정점에서 닿을 수 있는 정점의 최단 경로를 구하는 알고리즘

> 다익스트라에 비해 음의 가중치도 계산이 가능하다.

각 점을 시작점으로 정하여 다익스트라 알고리즘으로 각각의 인접 정접의
최단 경로를 찾는 방법이다. 이때 `동적 계획법`을 추가하여 훨씬 간단하게
구현한 알고리즘이다.

동적 계획법으로 접근할 때 중요한 아이디어는 `경유 가능한 정점`이다! 모든
정점을 경유 가능한 점으로 고려하면서 모든 쌍의 최단 경로를 계산한다.

따라서 최단 경로를 구할때 부분 문제를 다음과 같이 정의할 수 있다.
![floyd equation](https://latex.codecogs.com/gif.latex?D_{ij}k) =
점{1,2,..., k}만을 경유 가능한 점으로 고려하여 점 i부터 점 j까지의
모든경로 중 가장 짧은 경로의 거리

#### pseudo code
```
Floyd-Warshall(dp[][])
    loop k -> n
        loop i -> n (i != k)
            loop j -> n (j != i, j != k)
                   dp[i][j] <- min(dp[i][k] + dp[k][j], dp[i][j]
```
