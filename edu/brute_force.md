# 완전 검색 & 그리디

> 완전 검색을 구현하기 위해 재귀를 주요 사용한다! 이유는 가지치기!

재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

## 반복 구조

loop에서 보통의 반복 구조는 다음과 같다.

1. 초기화 (loop initialization) : 반복되는 명령문을 실행하기 전에 (한 번만) 조건 검사에 사용할 변수의 초기값 설정
2. 조건 검사
3. 반복할 명령문 실행
4. 업데이트

## 재귀 구조

재귀의 정의는 두 부분으로 나뉜다.

1. 하나 또는 그 이상의 기본 경우 (즉, 재귀의 출구 / basis case)
2. 하나 또는 그 이상의 유도된 경우 (inductive case) : 새로운 집합의 원소를 생성하기 위해 결합되는 방법

위 정의를 통해 재귀함수를 기본 부분 (basis part) / 유도 파트 (inductive part)로 구성된다.
재귀 함수는 반복 구조에 비해 간결하고 이해하기 쉬운 코드가 된다. 단, 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다.
따라서, 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생한다.

## 재귀와 반복의 비교

 / | 재귀 | 반복
:---: | :---: | :---: |
종료 | 재귀 함수 호출이 종료되는 base case | 반복문의 종료조건
수행 시간 | (상대적)느림 | 빠름
메모리 공간 | (상대적)많이 사용 | 적게 사용
소스 코드 길이 | 짧고 간결 | 길다
소스 코드 형태 | 선택 구조 (if else) | 반복 구조 (for, while)
무한 반복시 | 스택 오버플로우 | CPU를 반복해서 점유

## 완전 탐색 기법

모든 경우의 수를 생성하고 테스트하여 수행 속도는 느리지만 해답을 찾지 못할 확률이 적은 기법

> 모든 경우의 수를 찾아보기 때문

위 완전 탐색에 `그리디 기법`이나 `동적 계획법`을 통해 효율적인 알고리즘으로 만들 수 있다.

따라서 주어진 문제를 풀때 먼저, 완전 검색으로 접근하여 해답을 도출할 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

> 완전검색의 대표적인 예로 `순열`, `조합`, `부분집합`과 같은 조합적 문제들과 연관된다.

## 조합적문제

대표적으로 여행사 문제가 조합적문제의 예시이다.

### 1. 순열

> 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것 

![permutation](https://latex.codecogs.com/gif.latex?\inline&space;{}_n\mathrm{P}_{k})

순열은 위와 같이 표현한다.

그리고 위 순열식은 다음과 같은 식이 된다.

![permutation equation](https://latex.codecogs.com/gif.latex?\inline&space;{}_n\mathrm{P}_{k}&space;=&space;n\times(n-1)\times(n-2)\times...\times(n-r&plus;1))

![permutation](https://latex.codecogs.com/gif.latex?\inline&space;{}_n\mathrm{P}_{k})은 ![n factorial](https://latex.codecogs.com/gif.latex?\inline&space;n!)이다.

순열의 경우 팩토리얼 복잡도를 가지므로 n이 12이상 되버리면 시간 복잡도는 폭발적으로 증가하게된다.

```python
def perm(n, k):
    if k == n:
        print(array)
    else:
        for i in range(k, n):
            swap(k, i)
            perm(n, k+1)
            swap(k, i)
```

위 코드는 ![permutation](https://latex.codecogs.com/gif.latex?\inline&space;{}_n\mathrm{P}_{k})인 경우 사용하기 좋은 순열 코드이다.

```python
def perm(n, r, k):
    if r == 0:
        print(t)
    else:
        for i in range(n-1, -1, -1):
            a[n-1], a[i] = a[i], a[n-1]
            t[r-1] = a[n-1]
            test_perm(n-1, r-1, k)
            a[n-1], a[i] = a[i], a[n-1]
```

### 2. 부분집합

> 집합에 포함된 원소들을 선택하는 것.

n개의 원소를 포함한 집합에서 자기 자신과 공집합을 포함하여 모든 부분집합의 갯수는 ![2^n](https://latex.codecogs.com/gif.latex?2^n)개 이다.
원소의 수가 증가하면 부분집합의 갯수는 지수적으로 증가하게된다.

```python
def powerset(n, k):
    if n == k:
        printset(n)
        # 만약 n과 k의 값이 같아지면 부분집합의 대상이 될 원소가 없으므로 현재 부분집합 출력
    else:
        A[k] = 1  # k 지점의 값을 부분집합으로 지정
        powerset(n, k+1)
        A[k] = 0  # k 지점의 값을 부분집합으로 쓰지 않음
        powerset(n, k+1)
```

## 탐욕 알고리즘 (그리디)

탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적 방법

일반적으로, 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy한 접근이 된다.
단, 각 선택 시점에서 이뤄지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집했다고 해서 최종적인 해답이 되는 것은 아니다!

### 동작과정

1. 해선택 : 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해집합에 추가한다.
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행가능한지 확인한다.
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인한다. 만약 문제의 해가 완성되지 않았다면 1번부터 다시 시작한다.

### 탐욕 알고리즘의 필수 요소

1. 탐욕적 선택 속성 (greedy choice property)
    탐욕적 선택은 최적해로 갈 수 있음을 보이는 방법
    
    > 즉, 탐욕적 선택은 항상 안전하다!
    
2. 최적 부분 구조
    하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
    
이런 요소를 통해 `원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해`임을 증명해야한다.

 